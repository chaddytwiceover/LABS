<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Art Maker</title>
<style>
  :root{
    --bg: #0f1221;
    --panel: #151832;
    --panel-2:#1c2142;
    --text: #e8ebff;
    --muted:#9aa0c3;
    --accent:#7c9aff;
    --accent-2:#4be1a6;
    --danger:#ff6b6b;
    --grid:#2b2f56;
  }
  *{box-sizing:border-box;}
  html,body{height:100%;}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans";
    color: var(--text);
    background: radial-gradient(1200px 700px at 10% -10%, #1c2142 0%, var(--bg) 50%, #0a0d1a 100%);
    overflow:hidden;
  }
  header{
    display:flex;
    align-items:center;
    gap:.75rem;
    padding:.75rem 1rem;
    background: linear-gradient(180deg, #171b36, #131630);
    border-bottom:1px solid #1f2450;
    position:sticky; top:0; z-index:3;
  }
  header h1{font-size:1rem;margin:0;letter-spacing:.3px;color:#cdd3ff;white-space:nowrap;}
  .toolbar{
    display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; margin-left:auto;
  }
  .btn, .seg input+label{
    background:var(--panel-2);
    color:var(--text);
    border:1px solid #2a2f61;
    border-radius:.5rem;
    padding:.5rem .7rem;
    cursor:pointer;
    font-size:.9rem;
    line-height:1;
    user-select:none;
  }
  .btn:hover, .seg input:checked+label{outline:1px solid var(--accent); box-shadow:0 0 0 2px color-mix(in oklch, var(--accent) 25%, transparent)}
  .seg{display:flex; gap:.35rem; background:var(--panel); padding:.35rem; border-radius:.6rem; border:1px solid #262a54;}
  .seg input{display:none;}
  .seg label{display:inline-flex; align-items:center; gap:.4rem;}
  .seg label .swatch{width:1rem;height:1rem;border-radius:.2rem;border:1px solid #0003; box-shadow:inset 0 0 0 1px #fff2;}
  .row{display:flex; gap:.75rem; align-items:center; flex-wrap:wrap;}
  .row .field{display:flex; align-items:center; gap:.4rem; background:var(--panel); border:1px solid #262a54; padding:.35rem .5rem; border-radius:.5rem;}
  .row .field input[type="number"]{width:4.2rem;}
  input[type="number"], input[type="text"], select{
    background:transparent; border:1px solid #2a2f61; color:var(--text); padding:.35rem .45rem; border-radius:.45rem;
  }
  input[type="color"]{
    appearance:none; width:2rem; height:2rem; padding:0; border:1px solid #2a2f61; border-radius:.35rem; background:transparent; cursor:pointer;
  }
  input[type="range"]{accent-color:var(--accent); width:160px;}
  main{display:grid; grid-template-columns: 280px 1fr; grid-template-rows: auto 1fr; gap:0; height:calc(100% - 66px);}
  aside{
    grid-row:1 / span 2;
    padding:1rem;
    border-right:1px solid #1f2450;
    background: linear-gradient(180deg, #151938, #11142e);
    overflow:auto;
  }
  .panel{background:var(--panel); border:1px solid #262a54; border-radius:.75rem; padding:.8rem; margin-bottom:.8rem;}
  .panel h3{margin:.1rem 0 .6rem 0; font-size:.95rem; color:#bfc5ff;}
  .panel .row+.row{margin-top:.6rem;}
  .actions{display:flex; gap:.5rem; flex-wrap:wrap;}
  .actions .btn{background:#1b224a;}
  .danger{background: #2a1830; border-color:#4a264b;}
  .danger:hover{outline:1px solid var(--danger);}
  .canvas-wrap{
    position:relative;
    display:flex;
    align-items:center; justify-content:center;
    overflow:auto;
    background:
      linear-gradient(45deg,#141836 25%, transparent 25%) -16px 0/32px 32px,
      linear-gradient(-45deg,#141836 25%, transparent 25%) -16px 0/32px 32px,
      linear-gradient(45deg, transparent 75%, #141836 75%) -16px 0/32px 32px,
      linear-gradient(-45deg, transparent 75%, #141836 75%) -16px 0/32px 32px,
      #0e1124;
  }
  #stage{
    image-rendering: pixelated;
    box-shadow: 0 10px 30px rgba(0,0,0,.35), 0 0 0 1px #0007, inset 0 0 0 1px #fff1;
    background:#0000;
  }
  .grid-overlay{
    position:absolute; inset:0; pointer-events:none;
    background-size: var(--gsize) var(--gsize);
    background-image:
      linear-gradient(to right, var(--grid) 1px, transparent 1px),
      linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
    mix-blend-mode:screen;
    opacity:.7;
    display:none;
  }
  .grid-overlay.on{display:block;}
  footer{
    grid-column:2; padding:.6rem .9rem; font-size:.86rem;
    color:var(--muted); background:linear-gradient(180deg, transparent, #0d1021);
    border-top:1px solid #1f2450;
  }
  kbd{
    background:#0f1330; border:1px solid #2a2f61; border-bottom-color:#000; border-radius:.35rem; padding:.08rem .35rem; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#dfe4ff;
  }
  .spacer{flex:1;}
  .sr{position:absolute; left:-9999px;}
  .small{font-size:.82rem; color:var(--muted)}
</style>
</head>
<body>
  <header>
    <h1>üé® Pixel Art Maker</h1>
    <div class="toolbar">
      <div class="row">
        <div class="field">
          <label for="color">Color</label>
          <input id="color" type="color" value="#7c9aff" />
        </div>
        <div class="field">
          <label for="brush">Brush</label>
          <select id="brush">
            <option value="1">1 px</option>
            <option value="2">2 px</option>
            <option value="3">3 px</option>
            <option value="4">4 px</option>
            <option value="6">6 px</option>
            <option value="8">8 px</option>
            <option value="12">12 px</option>
          </select>
        </div>
        <div class="seg" role="radiogroup" aria-label="Tool">
          <input type="radio" name="tool" id="tool-pencil" value="pencil" checked>
          <label for="tool-pencil" title="Pencil (P)"><span>‚úèÔ∏è</span> Pencil</label>
          <input type="radio" name="tool" id="tool-eraser" value="eraser">
          <label for="tool-eraser" title="Eraser (E)"><span>ü©π</span> Eraser</label>
          <input type="radio" name="tool" id="tool-fill" value="fill">
          <label for="tool-fill" title="Fill/Bucket (F)"><span>ü™£</span> Fill</label>
          <input type="radio" name="tool" id="tool-picker" value="picker">
          <label for="tool-picker" title="Eyedropper (I)"><span>üéØ</span> Picker</label>
        </div>
        <div class="field">
          <label for="zoom">Zoom</label>
          <input id="zoom" type="range" min="1" max="40" step="1" value="20">
          <span id="zoomVal" class="small">20√ó</span>
        </div>
        <button class="btn" id="undo" title="Undo (Ctrl/Cmd+Z)">‚Ü∂ Undo</button>
        <button class="btn" id="redo" title="Redo (Ctrl/Cmd+Y)">‚Ü∑ Redo</button>
        <button class="btn" id="toggleGrid" title="Show/Hide Grid (G)"># Grid</button>
      </div>
    </div>
  </header>

  <main>
    <aside>
      <div class="panel">
        <h3>Canvas</h3>
        <div class="row">
          <div class="field"><label for="w">Width</label><input id="w" type="number" min="1" max="512" value="32"></div>
          <div class="field"><label for="h">Height</label><input id="h" type="number" min="1" max="512" value="32"></div>
          <button class="btn" id="resize">Resize</button>
        </div>
        <div class="row">
          <button class="btn" id="clear">Clear</button>
          <button class="btn danger" id="reset">Reset All</button>
        </div>
      </div>

      <div class="panel">
        <h3>Export</h3>
        <div class="row">
          <div class="field"><label for="scale">Scale</label>
            <select id="scale">
              <option>1</option><option>2</option><option>4</option><option selected>8</option>
              <option>10</option><option>16</option><option>20</option><option>32</option>
            </select>
          </div>
          <div class="field">
            <label for="bgMode">Background</label>
            <select id="bgMode">
              <option value="transparent">Transparent</option>
              <option value="color" selected>Solid</option>
            </select>
            <input id="bgColor" type="color" value="#0f1221" title="Background color"/>
          </div>
        </div>
        <div class="row actions">
          <button class="btn" id="exportPNG">Export PNG</button>
          <button class="btn" id="copyPNG" title="Copy to clipboard">Copy</button>
        </div>
        <p class="small">Tip: turn off the grid for a clean export ‚úîÔ∏è</p>
      </div>

      <div class="panel">
        <h3>Shortcuts</h3>
        <div class="small">
          <p><kbd>P</kbd> Pencil ‚Ä¢ <kbd>E</kbd> Eraser ‚Ä¢ <kbd>F</kbd> Fill ‚Ä¢ <kbd>I</kbd> Picker ‚Ä¢ <kbd>G</kbd> Grid</p>
          <p><kbd>Ctrl/Cmd</kbd> + <kbd>Z</kbd> Undo ‚Ä¢ <kbd>Ctrl/Cmd</kbd> + <kbd>Y</kbd> Redo</p>
          <p><kbd>1..7</kbd> Brush size ‚Ä¢ <kbd>+</kbd>/<kbd>-</kbd> Zoom</p>
        </div>
      </div>

      <p class="small">Made with ‚ù§Ô∏è ‚Äî no libraries needed.</p>
    </aside>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="stage" width="32" height="32" aria-label="Pixel canvas" role="img"></canvas>
      <div class="grid-overlay" id="grid"></div>
    </div>

    <footer>
      <span id="status">Ready.</span>
    </footer>
  </main>

<script>
(() => {
  "use strict";

  // --- Elements
  const stage = document.getElementById('stage');
  const ctx = stage.getContext('2d', { willReadFrequently: true });
  const wrap = document.getElementById('canvasWrap');
  const grid = document.getElementById('grid');

  const colorEl = document.getElementById('color');
  const brushEl = document.getElementById('brush');
  const zoomEl  = document.getElementById('zoom');
  const zoomVal = document.getElementById('zoomVal');
  const toolRadios = [...document.querySelectorAll('input[name="tool"]')];

  const wEl = document.getElementById('w');
  const hEl = document.getElementById('h');
  const resizeBtn = document.getElementById('resize');
  const clearBtn = document.getElementById('clear');
  const resetBtn = document.getElementById('reset');

  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  const gridBtn = document.getElementById('toggleGrid');

  const scaleEl = document.getElementById('scale');
  const bgModeEl = document.getElementById('bgMode');
  const bgColorEl = document.getElementById('bgColor');
  const exportBtn = document.getElementById('exportPNG');
  const copyBtn   = document.getElementById('copyPNG');

  const statusEl = document.getElementById('status');

  // --- State
  let W = 32, H = 32;          // logical pixels
  let zoom = +zoomEl.value;    // CSS pixel size per logical pixel
  let tool = 'pencil';
  let brush = +brushEl.value;  // brush diameter in logical pixels
  let drawing = false;
  let data = new Uint32Array(W * H);  // ABGR (using Canvas getImageData/set)
  let undoStack = [], redoStack = [];
  const MAX_STACK = 100;

  // Utilities
  const hexToRGBA = (hex) => {
    const h = hex.replace('#','');
    const n = h.length === 3
      ? h.split('').map(ch => ch+ch).join('')
      : h;
    const r = parseInt(n.slice(0,2),16);
    const g = parseInt(n.slice(2,4),16);
    const b = parseInt(n.slice(4,6),16);
    return {r,g,b,a:255};
  };
  const rgbaToUint32 = ({r,g,b,a}) => (a<<24) | (b<<16) | (g<<8) | r;
  const uint32ToRGBA = (u) => ({ r: u & 255, g: (u>>8)&255, b:(u>>16)&255, a:(u>>24)&255 });

  function pushUndo() {
    if (undoStack.length && undoStack[undoStack.length-1].W===W && undoStack[undoStack.length-1].H===H) {
      // store diff? For simplicity store full snapshot (fast enough for <= 512¬≤)
    }
    undoStack.push({ W, H, buf: new Uint32Array(data) });
    if (undoStack.length > MAX_STACK) undoStack.shift();
    redoStack.length = 0;
    syncUndoRedoUI();
  }

  function applySnapshot(snap) {
    W = snap.W; H = snap.H;
    data = new Uint32Array(snap.buf);
    resizeCanvasPixels(W, H, false);
    renderAll();
  }

  function undo() {
    if (!undoStack.length) return;
    const cur = { W, H, buf: new Uint32Array(data) };
    const prev = undoStack.pop();
    redoStack.push(cur);
    applySnapshot(prev);
    syncUndoRedoUI();
  }
  function redo() {
    if (!redoStack.length) return;
    const cur = { W, H, buf: new Uint32Array(data) };
    const next = redoStack.pop();
    undoStack.push(cur);
    applySnapshot(next);
    syncUndoRedoUI();
  }
  function syncUndoRedoUI(){
    undoBtn.disabled = undoStack.length===0;
    redoBtn.disabled = redoStack.length===0;
  }

  function setStatus(msg){ statusEl.textContent = msg; }

  // --- Canvas helpers
  function resizeCanvasPixels(w,h, keep = true) {
    // Save current to temp for nearest-neighbor copy
    const oldW = W, oldH = H, oldData = new Uint32Array(data);
    stage.width = w;
    stage.height = h;
    W = w; H = h;
    data = new Uint32Array(W*H);
    if (keep) {
      // Fit into new size preserving top-left; or scale if sizes differ?
      const copyW = Math.min(oldW, W);
      const copyH = Math.min(oldH, H);
      for (let y=0; y<copyH; y++){
        data.set(oldData.subarray(y*oldW, y*oldW + copyW), y*W);
      }
    }
    // grid size css var
    grid.style.setProperty('--gsize', `${zoom}px`);
  }

  function renderAll() {
    // Write Uint32 buffer to canvas
    const img = ctx.createImageData(W, H);
    const buf32 = new Uint32Array(img.data.buffer);
    buf32.set(data);
    ctx.putImageData(img, 0, 0);
    // CSS scale
    stage.style.width = (W * zoom) + 'px';
    stage.style.height = (H * zoom) + 'px';
    grid.style.width = stage.style.width;
    grid.style.height = stage.style.height;
    grid.style.setProperty('--gsize', `${zoom}px`);
  }

  function setPixel(x,y, u32color){
    if (x<0||y<0||x>=W||y>=H) return;
    data[y*W + x] = u32color;
  }
  function getPixel(x,y){
    if (x<0||y<0||x>=W||y>=H) return 0;
    return data[y*W + x];
  }

  function drawDot(cx, cy, radius, u32color) {
    // filled circle brush
    const r = Math.max(0, radius|0);
    const r2 = r*r;
    for (let y=-r; y<=r; y++){
      const yy = cy + y;
      if (yy<0||yy>=H) continue;
      const dy2 = y*y;
      for (let x=-r; x<=r; x++){
        if (x*x + dy2 <= r2) {
          const xx = cx + x;
          if (xx<0||xx>=W) continue;
          setPixel(xx, yy, u32color);
        }
      }
    }
  }

  function line(x0,y0,x1,y1, radius, u32) {
    // Bresenham-like step with circle brush
    let dx = Math.abs(x1-x0), sx = x0<x1?1:-1;
    let dy = -Math.abs(y1-y0), sy = y0<y1?1:-1;
    let err = dx+dy;
    while (true) {
      drawDot(x0,y0,radius,u32);
      if (x0===x1 && y0===y1) break;
      const e2 = 2*err;
      if (e2 >= dy) { err += dy; x0 += sx; }
      if (e2 <= dx) { err += dx; y0 += sy; }
    }
  }

  function floodFill(sx,sy, target, replacement) {
    if (target === replacement) return;
    if (getPixel(sx,sy) !== target) return;
    const q = [];
    q.push([sx,sy]);
    setPixel(sx,sy,replacement);
    while (q.length) {
      const [x,y] = q.pop();
      // 4-neighborhood
      if (x>0 && getPixel(x-1,y)===target){ setPixel(x-1,y,replacement); q.push([x-1,y]); }
      if (x+1<W && getPixel(x+1,y)===target){ setPixel(x+1,y,replacement); q.push([x+1,y]); }
      if (y>0 && getPixel(x,y-1)===target){ setPixel(x,y-1,replacement); q.push([x,y-1]); }
      if (y+1<H && getPixel(x,y+1)===target){ setPixel(x,y+1,replacement); q.push([x,y+1]); }
    }
  }

  // --- Input handling
  function canvasToPixel(clientX, clientY){
    const rect = stage.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left) / zoom);
    const y = Math.floor((clientY - rect.top) / zoom);
    return {x,y};
  }

  let lastXY = null;

  function startStroke(ev){
    ev.preventDefault();
    const p = getPoint(ev);
    if (!p) return;
    pushUndo();
    drawing = true;
    lastXY = p;

    const col = rgbaToUint32(hexToRGBA(colorEl.value));
    const br = Math.max(1, Math.round(+brushEl.value/2)); // brush radius
    const current = getPixel(p.x, p.y);

    if (tool === 'pencil'){
      drawDot(p.x, p.y, br, col);
    } else if (tool === 'eraser'){
      const transparent = 0x00000000; // erase to transparent
      drawDot(p.x, p.y, br, transparent);
    } else if (tool === 'fill'){
      floodFill(p.x, p.y, current, col);
    } else if (tool === 'picker'){
      const rgba = uint32ToRGBA(current);
      const hex = "#" + [rgba.r,rgba.g,rgba.b].map(v=>v.toString(16).padStart(2,'0')).join('');
      colorEl.value = hex;
      setStatus(`Picked ${hex}`);
    }
    renderAll();
  }

  function moveStroke(ev){
    if (!drawing) return;
    ev.preventDefault();
    const p = getPoint(ev);
    if (!p) return;
    const col = rgbaToUint32(hexToRGBA(colorEl.value));
    const br = Math.max(1, Math.round(+brushEl.value/2));
    if (tool === 'pencil'){
      line(lastXY.x, lastXY.y, p.x, p.y, br, col);
    } else if (tool === 'eraser'){
      const transparent = 0x00000000;
      line(lastXY.x, lastXY.y, p.x, p.y, br, transparent);
    }
    lastXY = p;
    renderAll();
  }

  function endStroke(ev){
    if (!drawing) return;
    drawing = false;
    lastXY = null;
  }

  function getPoint(ev){
    if (ev.touches && ev.touches[0]){
      const t = ev.touches[0];
      const p = canvasToPixel(t.clientX, t.clientY);
      if (p.x<0||p.y<0||p.x>=W||p.y>=H) return null;
      return p;
    } else {
      const p = canvasToPixel(ev.clientX, ev.clientY);
      if (p.x<0||p.y<0||p.x>=W||p.y>=H) return null;
      return p;
    }
  }

  // Attach events
  stage.addEventListener('mousedown', startStroke);
  stage.addEventListener('mousemove', moveStroke);
  window.addEventListener('mouseup', endStroke);

  stage.addEventListener('touchstart', startStroke, {passive:false});
  stage.addEventListener('touchmove', moveStroke, {passive:false});
  stage.addEventListener('touchend', endStroke);

  // Prevent drag image ghost
  stage.addEventListener('dragstart', (e)=>e.preventDefault());

  // --- Controls
  toolRadios.forEach(r => r.addEventListener('change', () => {
    if (r.checked) tool = r.value;
  }));
  brushEl.addEventListener('change', () => brush = +brushEl.value);

  zoomEl.addEventListener('input', () => {
    zoom = +zoomEl.value;
    zoomVal.textContent = `${zoom}√ó`;
    renderAll();
  });

  gridBtn.addEventListener('click', () => {
    grid.classList.toggle('on');
  });

  resizeBtn.addEventListener('click', () => {
    const nw = clamp(+wEl.value|0, 1, 512);
    const nh = clamp(+hEl.value|0, 1, 512);
    pushUndo();
    resizeCanvasPixels(nw, nh, true);
    renderAll();
    setStatus(`Resized to ${W}√ó${H}`);
  });

  clearBtn.addEventListener('click', () => {
    pushUndo();
    data.fill(0);
    renderAll();
  });

  resetBtn.addEventListener('click', () => {
    pushUndo();
    data.fill(0);
    W=32; H=32;
    wEl.value=W; hEl.value=H;
    resizeCanvasPixels(W,H,false);
    zoomEl.value=20; zoom=20; zoomVal.textContent='20√ó';
    grid.classList.remove('on');
    colorEl.value='#7c9aff';
    brushEl.value='1';
    toolRadios.find(r=>r.value==='pencil').checked=true; tool='pencil';
    renderAll();
    setStatus('Reset.');
  });

  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  // --- Export
  exportBtn.addEventListener('click', exportPNG);
  copyBtn.addEventListener('click', copyPNG);
  bgModeEl.addEventListener('change', () => {
    bgColorEl.disabled = bgModeEl.value!=='color';
  });
  bgColorEl.disabled = bgModeEl.value!=='color';

  function exportPNG(){
    const scale = +scaleEl.value;
    const {canvas: out, ctx: octx} = createExportCanvas(scale);
    const url = out.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = `pixel-art_${W}x${H}@${scale}x.png`;
    a.click();
    setStatus(`Exported ${W*scale}√ó${H*scale} PNG ‚úîÔ∏è`);
  }

  async function copyPNG(){
    const scale = +scaleEl.value;
    const {canvas: out} = createExportCanvas(scale);
    try{
      out.toBlob(async (blob) => {
        if (!blob) return;
        const item = new ClipboardItem({ 'image/png': blob });
        await navigator.clipboard.write([item]);
        setStatus('Copied PNG to clipboard ‚úîÔ∏è');
      });
    } catch (e){
      console.error(e);
      setStatus('Copy failed (browser not supported) ‚ùó');
    }
  }

  function createExportCanvas(scale=8){
    const out = document.createElement('canvas');
    out.width = W*scale;
    out.height = H*scale;
    const octx = out.getContext('2d');
    // Background
    if (bgModeEl.value === 'color'){
      octx.fillStyle = bgColorEl.value;
      octx.fillRect(0,0,out.width,out.height);
    } else {
      // keep transparent (default)
    }
    // Draw pixels scaled with nearest-neighbor
    octx.imageSmoothingEnabled = false;
    const img = ctx.createImageData(W, H);
    new Uint32Array(img.data.buffer).set(data);
    // put on a temp canvas then scale drawImage
    const tmp = document.createElement('canvas');
    tmp.width=W; tmp.height=H;
    const tctx = tmp.getContext('2d');
    tctx.putImageData(img,0,0);
    octx.drawImage(tmp, 0,0, out.width, out.height);
    return { canvas: out, ctx: octx };
  }

  // --- Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.target.matches('input, select, textarea')) return;
    const k = e.key.toLowerCase();
    if ((e.ctrlKey||e.metaKey) && k==='z'){ e.preventDefault(); undo(); return; }
    if ((e.ctrlKey||e.metaKey) && k==='y'){ e.preventDefault(); redo(); return; }
    if (k==='p'){ toolSet('pencil'); }
    else if (k==='e'){ toolSet('eraser'); }
    else if (k==='f'){ toolSet('fill'); }
    else if (k==='i'){ toolSet('picker'); }
    else if (k==='g'){ grid.classList.toggle('on'); }
    else if (k==='+' || k==='='){ zoomEl.value = Math.min(+zoomEl.max, +zoomEl.value + 1); zoomEl.dispatchEvent(new Event('input')); }
    else if (k==='-'){ zoomEl.value = Math.max(+zoomEl.min, +zoomEl.value - 1); zoomEl.dispatchEvent(new Event('input')); }
    else if (k>='1' && k<='7'){ // map to brush options
      const idx = +k - 1;
      const opts = [...brushEl.options];
      if (opts[idx]) { brushEl.value = opts[idx].value; brush = +brushEl.value; }
    }
  });

  function toolSet(name){
    const radio = toolRadios.find(r=>r.value===name);
    if (radio){ radio.checked = true; tool = name; }
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // --- Init: transparent canvas
  function initBlank() {
    data.fill(0);
    renderAll();
    syncUndoRedoUI();
    setStatus('Ready. Draw away!');
  }
  initBlank();

  // Optional: draw a starter smile to show it works (comment out if undesired)
  // pushUndo();
  // for (let x=8;x<24;x++) setPixel(x,8, rgbaToUint32(hexToRGBA('#ffd166')));
  // renderAll();

})();
</script>
</body>
</html>
